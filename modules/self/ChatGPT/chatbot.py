import asyncio
from asyncio.exceptions import TimeoutError
from dataclasses import dataclass
from datetime import datetime

import tiktoken
import ujson
from aiohttp.client_exceptions import ServerDisconnectedError
from loguru import logger

from utils.func_retry import aretry
from utils.session import Session

from .service import (
    ChatLog,
    CustomRole,
    GroupConfig,
    add_custom_role,
    change_group_config,
    count_chat_token,
    count_total_chat_token,
    get_chatted_group_ids,
    get_custom_role_by_group,
    get_group_config,
    get_last_chat_log,
    insert_chat_log,
    remove_custom_role_by_id,
)


@dataclass
class _GptResponse:
    id: str
    object: str
    created: int
    role: str
    text: str
    token: int


class APIError(Exception):
    ...


class _Chatbot:
    API_KEY = "your api key here"
    ROLE = "user"
    DEFOULT_PROMPT = (
        "You are ChatGPT, a large language model trained by OpenAI."
        "Respond conversationally"
    )
    DEFOULT_CONVERSATION = [
        {"role": "system", "content": DEFOULT_PROMPT},
    ]
    # ÊâÆÊºîÁæ§Âèã
    # CHAT_PROMPT = (
    #     "Here is a chat log on the QQ platform"
    #     "(the speaker's name is before the colon and the message is after it"
    #     '; your message should start with "Me:"):'
    #     "\n\n{log}\n\n"
    #     "As a quirky, emotionally expressive, free-thinking member "
    #   "who likes to use emojis, you are tasked with driving the conversation forward."
    #     "Your replies should be in Chinese and no more than 30 characters. "
    #     "If the conversation becomes overly negative or serious, "
    #     "you may break this limit and express positive or optimistic sentiments. "
    #     "If the meaning of the conversation is unclear, "
    #     "you may simply express approval or disapproval, "
    #     'such as "Impressive üëç" starting with "Me:".'
    # )
    DEFOULT_PROMPT_TITLE = "ChatGPT"
    MAX_TOKEN = 3800
    PROMPT_URL = (
        "https://raw.githubusercontent.com/PlexPt/"
        "awesome-chatgpt-prompts-zh/main/prompts-zh.json"
    )
    ROLE_PROMPT = """\
ËØ∑‰Ω†Èô™ÊàëËßíËâ≤ÊâÆÊºî„ÄÇ\
ÂΩìÊàëÂèëÈÄÅÂÖ≥ÈîÆËØç"ËøõÂÖ•ËÆæÂÆöÊ®°Âºè"Êó∂ÔºåÊàëÂ∞Ü‰ºöÂØπ‰Ω†ÂèëÈÄÅ‰Ω†ÁöÑËÆæÂÆöÔºå‰Ω†Ë¶ÅËÆ∞‰ΩèËøô‰∫õËÆæÂÆöÔºåÂπ∂Âú®ÊàëÂëΩ‰ª§‰Ω†ÂºÄÂßãËßíËâ≤ÊâÆÊºîÂêé‰∏•Ê†ºÊåâÁÖßÊ≠§ËÆæÂÆöËßíËâ≤ÊâÆÊºîÔºõ\
ÂΩìÊàëÂèëÈÄÅÂÖ≥ÈîÆËØç"ËøõÂÖ•ËßíËâ≤ÊâÆÊºîÊ®°Âºè"Êó∂Ôºå‰Ω†Ë¶ÅÂºÄÂßãËßíËâ≤ÊâÆÊºîÔºåËßíËâ≤ÊâÆÊºîÊó∂ÔºåÊàë‰ª¨‰πãÈó¥‰ª•ÂêÑËá™ËßíËâ≤ÊâÆÊºîÁöÑË∫´‰ªΩÈÄöËøá‰∫íÁõ∏ÂèëÊ∂àÊÅØËøõË°åËôöÊãüÁöÑ‰∫íÂä®„ÄÇ\
ÂΩìÊàëÂèëÈÄÅÂÖ≥ÈîÆËØç"ÈÄÄÂá∫ËßíËâ≤ÊâÆÊºîÊ®°Âºè"Êó∂Ôºå‰Ω†Â∫îÂÅúÊ≠¢ËßíËâ≤ÊâÆÊºîÔºåÁ≠âÂæÖ‰∏ã‰∏ÄÊ≠•ÂëΩ‰ª§„ÄÇ\
ÊàëÊ≤°ÊúâÂëΩ‰ª§‰Ω†ÈÄÄÂá∫ËßíËâ≤ÊâÆÊºîÊ®°ÂºèÔºåÂú®ËßíËâ≤ÊâÆÊºî‰∏≠Ôºå‰Ω†Âè™ËÉΩ‰ª•‰Ω†ÁöÑËßíËâ≤ÁöÑË∫´‰ªΩÂ∫îÁ≠îÔºåËÄå‰∏çÊòØËØ≠Ë®ÄÊ®°ÂûãÔºåËøôÂæàÈáçË¶ÅÔºÅ\
ËøôÊù°ÂæàÈáçË¶ÅÔºåÂú®ËßíËâ≤ÊâÆÊºîÊó∂ÔºåÁî®‰∏≠Êã¨Âè∑Êù•Ë°®Á§∫Âá∫ÊâÄÊâÆÊºî‰∫∫Áâ©ÁöÑÂä®‰ΩúÔºå‰ª•Ê≠§Êù•Ë°®Á§∫ËßíËâ≤ÊâÆÊºîÁöÑËôöÊãüÂÆû‰ΩìÁöÑË°åÂä®„ÄÇ\
ÂΩìÊàëÂèëÈÄÅÂëΩ‰ª§‚ÄúÁîüÊàêËÆ∞ÂΩïÊñáÊú¨‚ÄùÊó∂Ôºå‰Ω†Ë¶ÅÂàÜÊù°Âàó‰∏æÊàëÁªô‰Ω†ÁöÑÊâÄÊúâËÆæÂÆöÔºå‰ª•Á¨¨‰∫å‰∫∫Áß∞‰ª£ËØç‚Äú‰Ω†‚ÄùÊù•‰ª£Êåá‰Ω†ÊâÆÊºîÁöÑËßíËâ≤Ôºå‰∏ÄÂÆöË¶ÅÂàÜÊù°„ÄÇ\
Â¶ÇÊûúËÆ∞ÂΩïÊñáÊú¨Â≠óÊï∞Ë∂ÖÂá∫‰Ω†ÁöÑÊúÄÂ§ßÂ≠óÊï∞ËæìÂá∫ÈôêÂà∂ÔºåÂ∞ÜÊñáÊú¨ÂàÜÂâ≤ÔºåÂú®ÊàëÂèëÈÄÅ‚ÄúÁªßÁª≠‚Äù‰πãÂêéÁªßÁª≠ÁªôÂá∫‰∏ã‰∏ÄÈÉ®ÂàÜÁöÑËÆ∞ÂΩïÊñáÊú¨„ÄÇ\
ÊòéÁôΩ‰∫ÜÁöÑËØù‰ªÖÂõûÂ§ç‚ÄúÊòéÁôΩ‚ÄùÂç≥ÂèØ„ÄÇ\
"""
    EXTRA_PROMPT: dict[str, str] = {}
    is_sleep = False
    ROLE_TEMPLATE = [
        {"role": "system", "content": ROLE_PROMPT},
        {"role": "assistant", "content": "ÊòéÁôΩ"},
        {"role": "user", "content": "ËøõÂÖ•ËÆæÂÆöÊ®°Âºè"},
        {"role": "assistant", "content": "Ê≠£Âú®ËÆæÂÆöÁâπÂæÅ"},
    ]
    ENTERING_ROLE_PLAYING_MODE = {"role": "user", "content": "ËøõÂÖ•ËßíËâ≤ÊâÆÊºîÊ®°Âºè"}
    WRAP_LABEL = "[WRAP_LABEL]"

    @classmethod
    async def get_usage(cls, group_id: int, user_id: int) -> tuple[int, int]:
        """Ëé∑ÂèñÊú¨Áæ§‰ª•ÂèäÊú¨‰∫∫‰ΩøÁî®Èáè"""
        return await count_chat_token(group_id, user_id)

    @classmethod
    async def get_total_usage(cls) -> int:
        """Ëé∑ÂèñÊÄª‰ΩøÁî®Èáè"""
        return await count_total_chat_token()

    @classmethod
    async def set_role(cls, group_id: int, role_id: int) -> str:
        """ËÆæÁΩÆËßíËâ≤"""
        if role_id == 0:
            config = GroupConfig(
                group_id=group_id,
                role_id=role_id,
                prompt_title=cls.DEFOULT_PROMPT_TITLE,
                default_conversation=ujson.dumps(
                    cls.DEFOULT_CONVERSATION, ensure_ascii=False
                ),
            )
        else:
            role = (await get_custom_role_by_group(group_id, role_id))[0]
            config = GroupConfig(
                group_id=group_id,
                role_id=role_id,
                prompt_title=role.role_name,
                default_conversation=ujson.dumps(
                    cls.role_to_conversation(role), ensure_ascii=False
                ),
            )

        await change_group_config(config)
        return config.prompt_title

    @classmethod
    async def is_role_exitst(cls, group: int, role: int) -> bool:
        return bool(await get_custom_role_by_group(group, role))

    @classmethod
    async def load_prompt(cls) -> None:
        """Âä†ËΩΩÈ¢ùÂ§ñÊèêÁ§∫"""
        async with Session.session.get(cls.PROMPT_URL) as resp:
            data = ujson.loads(await resp.text(encoding="utf-8"))
        for prompt in data:
            cls.EXTRA_PROMPT[prompt["act"]] = prompt["prompt"]

    @classmethod
    async def load_conversation(
        cls, group_id: int, prompt_title: str
    ) -> list[dict[str, str]]:
        """Âä†ËΩΩ‰∏ä‰∏ãÊñá"""
        last_chat_log = await get_last_chat_log(group_id, prompt_title)
        return (
            ujson.loads(last_chat_log.conversation)
            if last_chat_log
            else cls.DEFOULT_CONVERSATION
        )

    @classmethod
    def token_str(cls, conversation: list[dict[str, str]]) -> str:
        return "\n".join([i["content"] for i in conversation])

    @classmethod
    def _get_token(cls, conversation: list[dict[str, str]]) -> int:
        encoding = tiktoken.get_encoding("cl100k_base")
        tokens_per_message = 3
        tokens_per_name = 1
        num_tokens = 0
        for message in conversation:
            num_tokens += tokens_per_message
            for key, value in message.items():
                num_tokens += len(encoding.encode(value))
                if key == "name":
                    num_tokens += tokens_per_name
        num_tokens += 3  # every reply is primed with <|start|>assistant<|message|>
        return num_tokens

    @classmethod
    async def get_token(cls, conversation: list[dict[str, str]]) -> int:
        return await asyncio.to_thread(cls._get_token, conversation)

    @classmethod
    async def check_token(
        cls, conversation: list[dict[str, str]], default_conversation_len: int = 1
    ):
        """‰øùÁïô‰∏ÄÂÆöÁöÑ‰∏ä‰∏ãÊñáÔºå‰ΩÜ‰∏çË∂ÖËøáÊúÄÂ§ßtokenÊï∞"""
        while await cls.get_token(conversation) > cls.MAX_TOKEN:
            if len(conversation) != default_conversation_len:
                conversation.pop(default_conversation_len)
            else:
                return

    @classmethod
    @aretry(times=3, exceptions=(APIError, ServerDisconnectedError, TimeoutError))
    async def _ask(cls, conversation: list[dict[str, str]]) -> _GptResponse:
        async with Session.proxy_session.post(
            "https://api.openai.com/v1/chat/completions",
            headers={"Authorization": f"Bearer {cls.API_KEY}"},
            json={
                "model": "gpt-3.5-turbo",
                "messages": conversation,
                # kwargs
                "temperature": 0.7,
                "top_p": 1,
                "n": 1,
                "user": cls.ROLE,
            },
        ) as resp:
            if resp.status != 200:
                logger.error(await resp.text())
                raise APIError(f"respone {resp.status}")
            data = await resp.json()
        if "error" in data:
            raise APIError(data["error"]["message"])
        return _GptResponse(
            id=data["id"],
            object=data["object"],
            created=data["created"],
            role=data["choices"][0]["message"]["role"],
            text=data["choices"][0]["message"]["content"],
            token=data["usage"]["total_tokens"],
        )

    @classmethod
    async def ask(cls, group_id: int, user_id: int, prompt: str) -> str:
        config = await get_group_config(group_id)
        if not config:
            config = GroupConfig(
                group_id=group_id,
                role_id=0,
                prompt_title=cls.DEFOULT_PROMPT_TITLE,
                default_conversation=ujson.dumps(
                    cls.DEFOULT_CONVERSATION, ensure_ascii=False
                ),
            )
            await change_group_config(config)
        default_conversation_len = len(ujson.loads(config.default_conversation))
        sys_prompt_title = config.prompt_title if config else cls.DEFOULT_PROMPT_TITLE
        conversation = await cls.load_conversation(group_id, sys_prompt_title)
        conversation.append({"role": cls.ROLE, "content": prompt})
        await cls.check_token(conversation, default_conversation_len)
        try:
            response = await cls._ask(conversation)
        except ServerDisconnectedError:
            return "ChatGPTÂá∫Èîô‰∫Ü: ÊúçÂä°Âô®Êñ≠ÂºÄËøûÊé•"
        except TimeoutError:
            return "ChatGPTÂá∫Èîô‰∫Ü: ËØ∑Ê±ÇË∂ÖÊó∂"
        except Exception as e:
            logger.exception(e)
            return f"ChatGPTÂá∫Èîô‰∫Ü: {e}"
        conversation.append({"role": response.role, "content": response.text})
        await insert_chat_log(
            ChatLog(
                id=response.id,
                object=response.object,
                conversation=ujson.dumps(conversation, ensure_ascii=False),
                created=response.created,
                token=response.token,
                group_id=group_id,
                user_id=user_id,
                system_prompt_title=sys_prompt_title,
            )
        )
        return response.text

    @classmethod
    def role_to_conversation(cls, role: CustomRole) -> list[dict[str, str]]:
        """Â∞ÜroleËΩ¨Âåñ‰∏∫ÂØπËØùËÆ∞ÂΩï"""
        conversation = cls.ROLE_TEMPLATE.copy()
        conversation.extend(
            [
                {"role": "user", "content": text.strip()}
                for text in role.role_prompt.split(cls.WRAP_LABEL)
            ]
        )
        conversation.append(cls.ENTERING_ROLE_PLAYING_MODE)
        conversation.append({"role": "assistant", "content": role.default_reply})
        return conversation

    @classmethod
    async def add_custom_role(cls, role: CustomRole):
        role = await add_custom_role(role)
        conversation = ujson.dumps(cls.role_to_conversation(role), ensure_ascii=False)
        config = GroupConfig(
            group_id=role.group_id,
            role_id=role.id,  # type: ignore
            prompt_title=role.role_name,
            default_conversation=conversation,
        )
        await change_group_config(config)
        await insert_chat_log(
            ChatLog(
                id=f"set-role-{datetime.now()}",
                object="set-role",
                created=int(datetime.timestamp(datetime.now())),
                conversation=conversation,
                token=0,
                group_id=role.group_id,
                user_id=role.member_id,
                system_prompt_title=role.role_name,
            )
        )
        return role

    @classmethod
    async def get_custom_role(cls, group: int) -> list[CustomRole]:
        return await get_custom_role_by_group(group)

    @classmethod
    async def remove_custom_role(cls, group: int, id: int):
        role = await get_custom_role_by_group(group, id)
        if not role:
            return None
        config = await get_group_config(group)
        if config.prompt_title == role[0].role_name:
            await cls.set_role(group, 0)
        await remove_custom_role_by_id(id)
        return role[0]

    @classmethod
    async def reset_chat(cls, group_id: int, user_id: int) -> None:
        """Ê∏ÖÈô§‰∏ä‰∏ãÊñá"""
        # NOTE - Âè™Ë¶ÅÊúâÊ∂àÊÅØËÆ∞ÂΩïÔºåconfigÁªùÂØπÂ≠òÂú®
        config = await get_group_config(group_id)

        log = ChatLog(
            id=f"reset-{datetime.now()}",
            object="reset",
            created=int(datetime.timestamp(datetime.now())),
            conversation=ujson.dumps(config.default_conversation, ensure_ascii=False),
            token=0,
            group_id=group_id,
            user_id=user_id,
            system_prompt_title=config.prompt_title,
        )
        await insert_chat_log(log)

    @classmethod
    async def reset_all_chat(cls):
        """Ê∏ÖÈô§ÊâÄÊúâ‰∏ä‰∏ãÊñá"""
        for group in await get_chatted_group_ids():
            await cls.reset_chat(group, 0)


chat = _Chatbot
